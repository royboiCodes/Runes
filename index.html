<!-- /mnt/data/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Runez</title>
<style>
  :root{--boardGray:#6e5236;--edge:#2f2317;--gold:#c3a13a;--silver:#b9c0c6;--goldDeep:#9f8126;--silverDeep:#8e959e;--woodA:#2b2016;--woodB:#3b2d20;--woodC:#5a422d;--woodD:#7a5a3c;--accent:#8e5e2e;}
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,'Helvetica Neue',Arial;}
  body{display:grid;grid-template-rows:auto 1fr auto;background:radial-gradient(120% 120% at 50% 0%, rgba(0,0,0,0.15), rgba(0,0,0,0)),linear-gradient(90deg, rgba(60,45,33,0.35) 0 1px, rgba(255,255,255,0) 1px) 0 0/16px 100%,repeating-linear-gradient(0deg,var(--woodD),var(--woodC) 24px,var(--woodB) 48px,var(--woodA) 72px);color:#eae3d7;}
  header,footer{padding:12px 18px;border-bottom:1px solid #5b4a37;background:linear-gradient(180deg, rgba(0,0,0,0.2), rgba(0,0,0,0)), repeating-linear-gradient(90deg, rgba(255,255,255,0.04), rgba(255,255,255,0.04) 2px, transparent 2px, transparent 6px);}
  footer{border-top:1px solid #5b4a37;border-bottom:none;display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  main{display:grid;grid-template-columns:1fr 420px;gap:18px;padding:18px;min-height:0;}
  @media (max-width: 1280px){ main{grid-template-columns:1fr;} }
  #boardWrap{border:1px solid #a6885e;border-radius:16px;overflow:auto;position:relative;height:800px;min-height:800px;max-width:100%;background:radial-gradient(130% 90% at 50% 10%, rgba(0,0,0,0.12), rgba(0,0,0,0)), linear-gradient(90deg, rgba(80,58,39,0.28) 0 1px, rgba(255,255,255,0) 1px) 0 0/16px 100%,repeating-linear-gradient(0deg,#e9d2aa,#e1c394 24px,#d8b781 48px,#d0ab74 72px);}#boardWrap:before,#boardWrap:after{content:'';position:absolute;width:26px;height:26px;border:2px solid #a6885e;border-radius:4px;opacity:.8;}#boardWrap:before{left:10px;top:10px;border-right:none;border-bottom:none;}#boardWrap:after{right:10px;bottom:10px;border-left:none;border-top:none;}
  #sidebar{border:1px solid #7a5a3c;border-radius:16px;padding:12px;display:grid;gap:12px;height:100%;min-height:0;background:linear-gradient(180deg, rgba(255,255,255,0.05), rgba(0,0,0,0)), repeating-linear-gradient(0deg,#5a422d,#4a3726 28px,#3f2e21 56px);}
  .stack{display:grid;gap:8px;}
  .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .stat{border:1px solid #826444;border-radius:12px;padding:10px;text-align:center;min-width:100px;background:linear-gradient(180deg, rgba(255,255,255,0.04), rgba(0,0,0,0));}
  .btn{padding:10px 14px;border-radius:10px;border:1px solid #b99357;background:linear-gradient(180deg,#b99357,#8b6d3e);color:#20170e;cursor:pointer;box-shadow:inset 0 1px 0 rgba(255,255,255,0.3);}
  .btn.ghost{background:linear-gradient(180deg,#685035,#4f3c2a);color:#f1e7d6;border-color:#8a6a46;}
  .log{height:180px;overflow:auto;border:1px solid #6f5338;border-radius:12px;padding:8px;background:linear-gradient(180deg, rgba(255,255,255,0.04), rgba(0,0,0,0));font-size:14px;}
  svg{touch-action:none; display:block; margin:auto; background:linear-gradient(90deg, rgba(60,45,33,0.18) 0 1px, rgba(255,255,255,0) 1px) 0 0/16px 100%,repeating-linear-gradient(0deg,#e2c298,#d9b583 24px,#d0a871 48px,#c99e67 72px);}
  .hint{fill:#22c55e;opacity:.2}
  .focusRing:focus{outline:2px solid #3b82f6;outline-offset:2px;border-radius:6px}
  .card{width:50px;height:76px;border-radius:8px;border:1px solid #333;display:flex;align-items:center;justify-content:center;user-select:none;font-size:26px}
  .card.gold{background:linear-gradient(180deg, var(--gold), var(--goldDeep));color:#2a230f;box-shadow:inset 0 1px 0 rgba(255,255,255,0.4);} .card.silver{background:linear-gradient(180deg, var(--silver), var(--silverDeep));color:#151922;box-shadow:inset 0 1px 0 rgba(255,255,255,0.4);}
  .chip{display:inline-flex;align-items:center;gap:8px}
  .gallery{display:flex;flex-wrap:wrap;gap:10px;justify-content:center;padding:18px 14px;border-top:1px solid #a6885e;background:linear-gradient(90deg, rgba(60,45,33,0.2) 0 1px, rgba(255,255,255,0) 1px) 0 0/16px 100%,repeating-linear-gradient(0deg,#dcc093,#d2b381 24px,#caa873 48px,#c39f6a 72px);}
  .gallery h4{flex-basis:100%;margin:6px 0 0 0;text-align:center;font-weight:600}
  .cardTall{width:52px;height:82px}
  .pendingBadge{position:absolute;right:12px;bottom:12px;background:#f59e0b;color:white;padding:6px 10px;border-radius:999px;font-size:12px}
  .coords{font-size:12px; fill:#111; opacity:.6; pointer-events:none}

  .panelGold{background:linear-gradient(180deg, rgba(195,161,58,0.22), rgba(159,129,38,0.12)); border-color:#b89a4c;}
  .panelSilver{background:linear-gradient(180deg, rgba(185,192,198,0.22), rgba(142,149,158,0.12)); border-color:#9ea6ad;}
  .handPanel{padding:6px;border:1px solid transparent;border-radius:10px;font-size:14px;}
  .statGold{background:linear-gradient(180deg, rgba(195,161,58,0.18), rgba(159,129,38,0.10)); border-color:#b89a4c;}
  .statSilver{background:linear-gradient(180deg, rgba(185,192,198,0.18), rgba(142,149,158,0.10)); border-color:#9ea6ad;}


  .mpdots{ display:flex; gap:8px; align-items:center; justify-content:center; }
  .mpDot{ width:16px; height:16px; border-radius:50%; border:2px solid #fff; background:transparent; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.25); }
  .mpDot.filled{ background:#fff; }
</style>
</head>
<body>
<header>
  <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
    <div class="chip"><strong>Gold</strong> ⏱ <span id="clock-orange">10:00</span></div>
    <div style="font-weight:600">Runez</div>
    <div class="chip"><strong>Silver</strong> ⏱ <span id="clock-blue">10:00</span></div>
  </div>
</header>
<main>
  <div id="boardWrap">
    <svg id="board" role="application" aria-label="Runez board"></svg>
    <div id="gallery-blue" class="row" style="justify-content:center;width:100%"></div>
    </div>
<div id="gallery" class="gallery">
      <h4>Full 24 Rune Decks</h4>
      <div id="gallery-orange" class="row" style="justify-content:center;width:100%"></div>
      

    <div id="pendingBadge" class="pendingBadge" style="display:none">Pending moves…</div>
  </div>
  <aside id="sidebar">
    <section class="stack handPanel" id="hand-panel">
      <h3 style="margin:4px 0">Your Hand (<span id="hand-owner">ORANGE</span>)</h3>
      <div class="row" id="hand"></div>
    </section>
    <section class="row">
      <div class="stat" id="stat-deck-me"><div>Your Deck</div><div style="font-size:20px" id="deck-me">—</div></div>
      <div class="stat" id="stat-discard-me"><div>Discard</div><div style="font-size:20px" id="discard-me">—</div></div>
      <div class="stat" id="stat-deck-opp"><div>Opp. Deck</div><div style="font-size:20px" id="deck-opp">—</div></div>
    </section>
    <section class="row">
      <div class="stat panelSilver" id="stat-mp-me"><div>Magic</div><div id="mp-me" class="mpdots"></div></div>
      <div class="stat" id="stat-mp-opp"><div>Opp. Magic</div><div id="mp-opp" class="mpdots"></div></div>
    </section>
    <section class="stack">
      <h3 style="margin:4px 0">Move Log</h3>
      <div class="log" id="log"></div>
    </section>
  </aside>
</main>
<footer>
  <button id="undoBtn" class="btn ghost">Undo</button>
  <button id="startGame" class="btn">Start Game</button>
  <button id="endTurn" class="btn">End Turn</button>
  <button id="resetPending" class="btn ghost">Reset pending</button>
  <span style="opacity:.7">22 cells, tight pointy-top honeycomb. Pawns placed per your C#R# list.</span>
</footer>

<script>
(() => {
  // 24 rune deck (visual only)
  const ELDER_24 = [
    {code:'FEHU',    sym:'ᚠ'},{code:'URUZ',   sym:'ᚢ'},{code:'THURISAZ',sym:'ᚦ'},{code:'ANSUZ', sym:'ᚨ'},
    {code:'RAIDHO',  sym:'ᚱ'},{code:'KAUNA',  sym:'ᚲ'},{code:'GEBO',    sym:'ᚷ'},{code:'WUNJO', sym:'ᚹ'},
    {code:'HAGALAZ', sym:'ᚺ'},{code:'NAUDIZ', sym:'ᚾ'},{code:'ISAZ',    sym:'ᛁ'},{code:'JERA',  sym:'ᛃ'},
    {code:'EIHWAZ',  sym:'ᛇ'},{code:'PERTHRO',sym:'ᛈ'},{code:'ALGIZ',   sym:'ᛉ'},{code:'SOWILO',sym:'ᛋ'},
    {code:'TIWAZ',   sym:'ᛏ'},{code:'BERKANO',sym:'ᛒ'},{code:'EHWAZ',   sym:'ᛖ'},{code:'MANNAZ',sym:'ᛗ'},
    {code:'LAGUZ',   sym:'ᛚ'},{code:'INGWAZ', sym:'ᛜ'},{code:'DAGAZ',   sym:'ᛞ'},{code:'OTHALA',sym:'ᛟ'},
  ];

  // Rune effect registry (placeholders)
  const RUNE_EFFECTS = {
    FEHU:{costMp:0,activate(s,ctx){ctx.log(`FEHU effect triggered by ${ctx.playerKey} at ${ctx.rune.cellId}.`)}},
    URUZ:{costMp:0,activate(s,ctx){ctx.log(`URUZ effect triggered by ${ctx.playerKey}.`)}},
    THURISAZ:{costMp:0,activate(s,ctx){ctx.log(`THURISAZ effect triggered by ${ctx.playerKey}.`)}},
    ANSUZ:{costMp:0,activate(s,ctx){ctx.log(`ANSUZ effect triggered by ${ctx.playerKey}.`)}},
    RAIDHO:{costMp:0,activate(s,ctx){ctx.log(`RAIDHO effect triggered by ${ctx.playerKey}.`)}},
    KAUNA:{costMp:0,activate(s,ctx){ctx.log(`KAUNA effect triggered by ${ctx.playerKey}.`)}},
    GEBO:{costMp:0,activate(s,ctx){ctx.log(`GEBO effect triggered by ${ctx.playerKey}.`)}},
    WUNJO:{costMp:0,activate(s,ctx){ctx.log(`WUNJO effect triggered by ${ctx.playerKey}.`)}},
    HAGALAZ:{costMp:0,activate(s,ctx){ctx.log(`HAGALAZ effect triggered by ${ctx.playerKey}.`)}},
    NAUDIZ:{costMp:0,activate(s,ctx){ctx.log(`NAUDIZ effect triggered by ${ctx.playerKey}.`)}},
    ISAZ:{costMp:0,activate(s,ctx){ctx.log(`ISAZ effect triggered by ${ctx.playerKey}.`)}},
    JERA:{costMp:0,activate(s,ctx){ctx.log(`JERA effect triggered by ${ctx.playerKey}.`)}},
    EIHWAZ:{costMp:0,activate(s,ctx){ctx.log(`EIHWAZ effect triggered by ${ctx.playerKey}.`)}},
    PERTHRO:{costMp:0,activate(s,ctx){ctx.log(`PERTHRO effect triggered by ${ctx.playerKey}.`)}},
    ALGIZ:{costMp:0,activate(s,ctx){ctx.log(`ALGIZ effect triggered by ${ctx.playerKey}.`)}},
    SOWILO:{costMp:0,activate(s,ctx){ctx.log(`SOWILO effect triggered by ${ctx.playerKey}.`)}},
    TIWAZ:{costMp:0,activate(s,ctx){ctx.log(`TIWAZ effect triggered by ${ctx.playerKey}.`)}},
    BERKANO:{costMp:0,activate(s,ctx){ctx.log(`BERKANO effect triggered by ${ctx.playerKey}.`)}},
    EHWAZ:{costMp:0,activate(s,ctx){ctx.log(`EHWAZ effect triggered by ${ctx.playerKey}.`)}},
    MANNAZ:{costMp:0,activate(s,ctx){ctx.log(`MANNAZ effect triggered by ${ctx.playerKey}.`)}},
    LAGUZ:{costMp:0,activate(s,ctx){ctx.log(`LAGUZ effect triggered by ${ctx.playerKey}.`)}},
    INGWAZ:{costMp:0,activate(s,ctx){ctx.log(`INGWAZ effect triggered by ${ctx.playerKey}.`)}},
    DAGAZ:{costMp:0,activate(s,ctx){ctx.log(`DAGAZ effect triggered by ${ctx.playerKey}.`)}},
    OTHALA:{costMp:0,activate(s,ctx){ctx.log(`OTHALA effect triggered by ${ctx.playerKey}.`)}},
  };

  // Geometry
  const size = 72;
  const h = size;
  const w = Math.sqrt(3) * size;
  const vStep = 1.5 * size;
  const xStep = w;
  const rowOffset = 0.5 * w;
  const columns = { 1:4, 2:5, 3:4, 4:5, 5:4 };
  const cells = {};
  const centers = {};
  const cellList = [];
  const levels = [1,2,3,4,5];
  const present = new Set([
    'C1R1','C2R1','C3R1','C4R1','C5R1',
    'C1R2','C2R2','C3R2','C4R2','C5R2',
    'C1R3','C2R3','C3R3','C4R3','C5R3',
    'C1R4','C2R4','C3R4','C4R4','C5R4',
    'C2R5','C4R5'
  ]);

  const svg = document.getElementById('board');

  function placeCells(){
    const S = size;
    const rt3 = Math.sqrt(3);
    const heights = [4,5,4,5,4];

    for (const k of Object.keys(centers)) delete centers[k];
    cellList.length = 0;

    const padX = 130, padY = 200;
    let maxX = 0, maxY = 0;

    for (let q=1; q<=5; q++){
      const hq = heights[q-1];
      for (let r=1; r<=hq; r++){
        const id = `C${q}R${r}`;
        let cx = padX + 1.5*S*(q-1);
        let cy = padY + rt3*S*((r-1) + 0.5*((q-1)%2));
        if (q===2 || q===4){ cy -= rt3*S; }
        centers[id] = { x: cx, y: cy };
        cells[id] = cells[id] || { id, col: q, row: r };
        cellList.push(id);
        if (cx>maxX) maxX=cx; if (cy>maxY) maxY=cy;
      }
    }

    const pad = S*2;
    const width  = Math.max(1200, Math.ceil(maxX + pad));
    const height = Math.max(900,  Math.ceil(maxY + pad));
    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
    svg.setAttribute('width',  Math.min(1800, width));
    svg.setAttribute('height', Math.min(1200, height));

    return { width, height };
  }

  // Graphs
  const edges = {}; // nodeId -> { id, pos, neighbors:[] }
  const nodeCells = {}; // (1) nodeId -> [cellId, ...]
  function hexPolygon(center, R=size){
    const pts=[];
    for (let i=0;i<6;i++){
      const ang = (Math.PI/3)*i;
      pts.push([center.x + R*Math.cos(ang), center.y + R*Math.sin(ang)]);
    }
    return pts;
  }
  function buildGraph(){
    for (const k of Object.keys(edges)) delete edges[k];
    for (const k of Object.keys(nodeCells)) delete nodeCells[k];

    const nodeMap = new Map();
    const getKey = (x,y) => `${Math.round(x/0.75)}:${Math.round(y/0.75)}`;
    const getNode = (x,y) => {
      const k = getKey(x,y);
      if (!nodeMap.has(k)){
        const id = `v${nodeMap.size.toString().padStart(4,'0')}`;
        nodeMap.set(k, id);
        edges[id] = { id, pos: {x,y}, neighbors: [] };
        nodeCells[id] = [];
      }
      return edges[nodeMap.get(k)];
    };
    const connect = (a,b) => {
      if (a.id===b.id) return;
      if (!a.neighbors.includes(b.id)) a.neighbors.push(b.id);
      if (!b.neighbors.includes(a.id)) b.neighbors.push(a.id);
    };

    for (const id of Object.keys(centers)){
      const verts = hexPolygon(centers[id], size);
      const nodesForHex = verts.map(([x,y]) => getNode(x,y));
      // 6-cycle
      for (let i=0;i<6;i++){
        const a = nodesForHex[i], b = nodesForHex[(i+1)%6];
        connect(a,b);
      }
      // (1) record node->cell incidence
      for (const n of nodesForHex){
        if (!nodeCells[n.id].includes(id)) nodeCells[n.id].push(id);
      }
    }
  }

  const dims = placeCells();
  buildGraph();

  // Pawns
  const pawns = {};
  let oid=0,bid=0;
  const allNodes = Object.values(edges);
  const minY = Math.min(...allNodes.map(n=>n.pos.y));
  const maxY = Math.max(...allNodes.map(n=>n.pos.y));
  function getExtremeVertices(targetY, count){
    const band = allNodes.filter(n => Math.abs(n.pos.y - targetY) < 20);
    band.sort((a,b)=>a.pos.x-b.pos.x);
    return band.slice(0,count);
  }
  const topVerts = getExtremeVertices(minY,4);
  const botVerts = getExtremeVertices(maxY,4);
  // Store startEdge for reset on Start Game + capture flags
  for (const n of topVerts){
    const id = `O${oid++}`;
    pawns[id] = { id, owner:'ORANGE', edge:n.id, startEdge:n.id, captured:false, skipOwnTurns:0 };
  }
  for (const n of botVerts){
    const id = `B${bid++}`;
    pawns[id] = { id, owner:'BLUE', edge:n.id, startEdge:n.id, captured:false, skipOwnTurns:0 };
  }

  const MP_MAX = 2;

  function logEvent(text){ state.log.push({ t: Date.now(), text }); }

  const state = {
    placedRunes: [],
    players: {
      ORANGE: { color:'ORANGE', pawns: Object.keys(pawns).filter(id=>id.startsWith('O')), deck: [], hand: [], discard: [], timeMs: 10*60*1000, name:'Gold' , mp: MP_MAX, mpMax: MP_MAX},
      BLUE:   { color:'BLUE',   pawns: Object.keys(pawns).filter(id=>id.startsWith('B')), deck: [], hand: [], discard: [], timeMs: 10*60*1000, name:'Silver'   , mp: MP_MAX, mpMax: MP_MAX},
    },
    turn: 'ORANGE',
    gameStarted: false,
    log: [{ t: Date.now(), text: 'v11 honeycomb ready. Orange to move.' }],
    turnCount: 0
  };

  // Decks/hands
  function makeDeck(owner){
    const order=[], cards={};
    for (let i=0;i<24;i++){ const id=`${owner}-card-${i}`; cards[id]={id,owner,code:ELDER_24[i].code,sym:ELDER_24[i].sym}; order.push(id); }
    return { cards, order };
  }
  const deckO = makeDeck('ORANGE'), deckB = makeDeck('BLUE');
  const cards = { ...deckO.cards, ...deckB.cards };
  state.players.ORANGE.hand = deckO.order.slice(0,24);
  state.players.BLUE.hand   = deckB.order.slice(0,24);

  function grantMagic(who, amt=1){ const p = state.players[who]; if (!p) return; p.mp = Math.min((p.mp||0) + amt, p.mpMax||MP_MAX); rerender(); }
  function spendMagic(who, amt=1){ const p = state.players[who]; if (!p) return false; if ((p.mp||0) < amt) return false; p.mp -= amt; rerender(); return true; }
  function resetAllMagic(){ state.players.ORANGE.mp = state.players.ORANGE.mpMax || MP_MAX; state.players.BLUE.mp   = state.players.BLUE.mpMax   || MP_MAX; }

  const pending = { pawnMoves: [], rune: null, runeMpSpent: false, captures: [] };
  function safeClearPendingRune(){ try{ if (pending.rune && pending.runeMpSpent){ const me = state.turn; state.players[me].mp = state.players[me].mpMax || MP_MAX; pending.runeMpSpent = false; } }catch(e){} pending.rune = null; }
  const previewEdges = {};
  const pendingBadge = document.getElementById('pendingBadge');

  const galleryO = document.getElementById('gallery-orange');
  const galleryB = document.getElementById('gallery-blue');
  const handEl = document.getElementById('hand');
  const logEl = document.getElementById('log');
  const deckMe = document.getElementById('deck-me');
  const discardMe = document.getElementById('discard-me');
  const deckOpp = document.getElementById('deck-opp');
  const statDiscard = document.getElementById('stat-discard-me');
  const statOpp = document.getElementById('stat-deck-opp');
  const handOwnerLabel = document.getElementById('hand-owner');

  // Populate ONLY Orange gallery
  for (let i=0;i<24;i++){
    const o = document.createElement('div'); o.className='card cardTall gold'; o.textContent=ELDER_24[i].sym; o.title=ELDER_24[i].code; galleryO.appendChild(o);
  }
  // Silver gallery not populated (spec)

  function polyPoints(center,R=size){
    const pts=[];
    for (let i=0;i<6;i++){
      const ang = (Math.PI/3)*i;
      pts.push(`${center.x + R*Math.cos(ang)},${center.y + R*Math.sin(ang)}`);
    }
    return pts.join(' ');
  }

  const nodes = edges; // alias

  function svgPoint(evt){
    const pt = svg.createSVGPoint(); pt.x = evt.clientX; pt.y = evt.clientY;
    const m = svg.getScreenCTM().inverse(); const p = pt.matrixTransform(m);
    return { x: p.x, y: p.y };
  }

  function nodeForPawn(pawnId){
    const edgeId = previewEdges[pawnId] || pawns[pawnId]?.edge;
    if (!edgeId) return null; // why: captured/off-board safe guard
    return nodes[edgeId];
  }
  function currentEdgeIdForPawn(pawnId){ return previewEdges[pawnId] || pawns[pawnId].edge; } // (2)

  let dragging = null; // {kind:'pawn'|'rune', id, owner?}
  let dragPoint = { x: 0, y: 0 };
  let dragPreviewTarget = null;

  function drawRuneAt(x,y,isOrange,sym,opacity){
    const r = document.createElementNS('http://www.w3.org/2000/svg','rect');
    r.setAttribute('x', x-24); r.setAttribute('y', y-34); r.setAttribute('width','48'); r.setAttribute('height','68'); r.setAttribute('rx','5');
    r.setAttribute('fill', isOrange? (getComputedStyle(document.documentElement).getPropertyValue('--gold').trim()||'#C8A949'):(getComputedStyle(document.documentElement).getPropertyValue('--silver').trim()||'#C0C0C8')); r.setAttribute('stroke','#333'); r.setAttribute('opacity', String(opacity));
    const t = document.createElementNS('http://www.w3.org/2000/svg','text');
    t.setAttribute('x', x); t.setAttribute('y', y+8); t.setAttribute('text-anchor','middle'); t.setAttribute('font-size','26');
    t.setAttribute('fill', isOrange? '#3e2f20':'#1f2430'); t.textContent = sym;
    svg.appendChild(r); svg.appendChild(t);
  }

  // (3) Compute legal rune cells from staged pawn positions
  function getLegalRuneCellsForCurrentPlayer(){
    const me = state.turn;
    const player = state.players[me];
    if (!player) return new Set();
    const result = new Set();
    for (const pid of player.pawns || []){
      const edgeId = currentEdgeIdForPawn(pid);
      const pawn = pawns[pid];
      if (!pawn || pawn.captured || !edgeId) continue; // skip captured/off-board
      const cellsForNode = nodeCells[edgeId] || [];
      for (const cellId of cellsForNode) result.add(cellId);
    }
    return result;
  }
  function isRunePlacementLegal(cellId, ownerKey){
    if (!cellId) return false;
    if (ownerKey !== state.turn) return false;
    const legal = getLegalRuneCellsForCurrentPlayer();
    return legal.has(cellId);
  }

  function renderBoard(){
    svg.innerHTML = '';
    // draw cells
    for (const id of cellList){
      const ctr = centers[id];
      const poly = document.createElementNS('http://www.w3.org/2000/svg','polygon');
      poly.setAttribute('points', polyPoints(ctr));
      poly.setAttribute('fill', getComputedStyle(document.documentElement).getPropertyValue('--boardGray').trim() || '#6e5236');
      poly.setAttribute('stroke', '#4b3a28'); poly.setAttribute('stroke-width','2');
      svg.appendChild(poly);

      // label C#R#
      const label = document.createElementNS('http://www.w3.org/2000/svg','text');
      label.setAttribute('x', ctr.x); label.setAttribute('y', ctr.y+6);
      label.setAttribute('text-anchor','middle'); label.setAttribute('class','coords'); label.textContent = id;
      svg.appendChild(label);
    }

    // legal rune cell hints ONLY for current player while dragging a rune
    if (dragging?.kind==='rune' && state.turn===dragging.owner){
      const legal = getLegalRuneCellsForCurrentPlayer();
      for (const id of cellList){
        if (!legal.has(id)) continue;
        const ctr = centers[id];
        const hint = document.createElementNS('http://www.w3.org/2000/svg','circle');
        hint.setAttribute('cx', ctr.x); hint.setAttribute('cy', ctr.y); hint.setAttribute('r','30'); hint.setAttribute('class','hint');
        svg.appendChild(hint);
      }
    }

    // pending rune ghost
    if (pending.rune && centers[pending.rune.cellId]){
      const ctr = centers[pending.rune.cellId]; const isOrange = pending.rune.cardId.startsWith('ORANGE');
      drawRuneAt(ctr.x, ctr.y, isOrange, cards[pending.rune.cardId].sym, 0.9);
    }

    // soft edge graph dots
    for (const e of Object.values(nodes)){
      const dot = document.createElementNS('http://www.w3.org/2000/svg','circle');
      dot.setAttribute('cx', e.pos.x); dot.setAttribute('cy', e.pos.y); dot.setAttribute('r','3'); dot.setAttribute('fill','#000'); dot.setAttribute('opacity','0.07');
      svg.appendChild(dot);
    }

    // highlights while dragging a pawn
    if (dragging?.kind==='pawn'){
      const p = pawns[dragging.id]; const n = nodeForPawn(p.id);
      if (n){ // guard if somehow off-board
        for (const nid of n.neighbors){
          const nb = nodes[nid];
          const hi = document.createElementNS('http://www.w3.org/2000/svg','circle');
          hi.setAttribute('cx', nb.pos.x); hi.setAttribute('cy', nb.pos.y); hi.setAttribute('r','14'); hi.setAttribute('class','hint');
          svg.appendChild(hi);
        }
      }
    }

    /*__PERSISTED_RUNES__*/
    if (Array.isArray(state.placedRunes)){
      state.placedRunes.forEach((pr, i) => {
        const ctr = centers[pr.cellId];
        const card = cards[pr.cardId];
        if (!ctr || !card) return;
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        const angle = (pr.angle || 0);
        g.setAttribute('transform', `rotate(${angle} ${ctr.x} ${ctr.y})`);
        g.style.cursor = 'pointer';

        g.addEventListener('click', (ev) => { handleRuneClick(i, ev); });

        const isMyTurn = (state.turn === pr.owner);
        if (!isMyTurn){
          g.style.pointerEvents = 'none';
          g.style.opacity = '0.8';
        } else {
          g.style.pointerEvents = 'auto';
        }

        const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
        rect.setAttribute('x', ctr.x-24); rect.setAttribute('y', ctr.y-34);
        rect.setAttribute('width','48'); rect.setAttribute('height','68'); rect.setAttribute('rx','5');
        const gold = getComputedStyle(document.documentElement).getPropertyValue('--gold').trim() || '#C8A949';
        const silver = getComputedStyle(document.documentElement).getPropertyValue('--silver').trim() || '#C0C0C8';
        rect.setAttribute('fill', pr.owner==='ORANGE'? gold : silver);
        rect.setAttribute('stroke','#333'); rect.setAttribute('opacity','0.95');
        if (pr.exhausted) rect.setAttribute('opacity','0.75');

        const t = document.createElementNS('http://www.w3.org/2000/svg','text');
        t.setAttribute('x', ctr.x); t.setAttribute('y', ctr.y+8);
        t.setAttribute('text-anchor','middle'); t.setAttribute('font-size','26');
        t.setAttribute('fill', pr.owner==='ORANGE'? '#3e2f20':'#1f2430');
        t.textContent = (card.sym || card.code || '');
        g.appendChild(rect); g.appendChild(t);
        svg.appendChild(g);
      });
    }

    // pawns (skip captured/off-board)
    for (const p of Object.values(pawns)){
      if (p.captured || !p.edge) continue;
      const n = nodeForPawn(p.id);
      if (!n) continue;
      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
      let cx=n.pos.x, cy=n.pos.y;
      if (dragging?.kind==='pawn' && dragging.id===p.id){ cx=dragPoint.x; cy=dragPoint.y; }
      circle.setAttribute('cx', cx); circle.setAttribute('cy', cy); circle.setAttribute('r','16');
      circle.setAttribute('fill', p.owner==='ORANGE'?getComputedStyle(document.documentElement).getPropertyValue('--gold').trim()||'#C8A949':getComputedStyle(document.documentElement).getPropertyValue('--silver').trim()||'#C0C0C8'); circle.setAttribute('stroke','#333'); circle.setAttribute('stroke-width','1.8');
      circle.setAttribute('tabindex','0'); circle.setAttribute('class','focusRing');
      const canDrag = state.turn===p.owner && ((p.mv||0)>0) && (pending.pawnMoves.length<4);
      if (canDrag){ circle.style.cursor='grab'; circle.style.pointerEvents='auto'; circle.addEventListener('pointerdown', ev => startPawnDrag(ev, p.id)); }
      else { circle.style.cursor='default'; circle.style.pointerEvents='none'; }
      svg.appendChild(circle);
    }
  }

  function renderMPDots(el, cur, max){
    el.innerHTML='';
    for (let i=0;i<max;i++){
      const d = document.createElement('div');
      d.className = 'mpDot' + (i < cur ? ' filled' : '');
      el.appendChild(d);
    }
  }
  function renderSidebar(){
    const me = state.turn; const opp = me==='ORANGE'?'BLUE':'ORANGE';
    const handOwnerLabel = document.getElementById('hand-owner');
    handOwnerLabel.textContent = (me==='ORANGE'?'GOLD':'SILVER');
    const handEl = document.getElementById('hand');
    handEl.innerHTML='';
    for (const id of state.players[me].hand){
      const el = document.createElement('div');
      el.className = 'card ' + (id.startsWith('ORANGE')?'gold':'silver');
      el.textContent = cards[id].sym;
      el.title = cards[id].code;
      el.setAttribute('role','button'); el.setAttribute('tabindex','0'); el.classList.add('focusRing');
      el.addEventListener('pointerdown', ev => startRuneDrag(ev, id, me));
      handEl.appendChild(el);
    }
    const deckMe = document.getElementById('deck-me');
    const discardMe = document.getElementById('discard-me');
    const deckOpp = document.getElementById('deck-opp');
    const logEl = document.getElementById('log');
    deckMe.textContent = ''+state.players[me].deck.length;
    discardMe.textContent = ''+state.players[me].discard.length;
    deckOpp.textContent = ''+state.players[opp].deck.length;
    statDiscard.classList.remove('statGold','statSilver');
    statOpp.classList.remove('statGold','statSilver');
    if (me==='ORANGE'){ statDiscard.classList.add('statGold'); }
    else { statDiscard.classList.add('statSilver'); }
    logEl.innerHTML = state.log.map(l=>`<div>${new Date(l.t).toLocaleTimeString()} — ${l.text}</div>`).join('');
    logEl.scrollTop = logEl.scrollHeight;
    try{
      renderMPDots(document.getElementById('mp-me'), state.players[me].mp||0, state.players[me].mpMax||MP_MAX);
      renderMPDots(document.getElementById('mp-opp'), state.players[opp].mp||0, state.players[opp].mpMax||MP_MAX);
    }catch(e){}

    const pendingBadge = document.getElementById('pendingBadge');
    const hasPending = pending.pawnMoves.length>0 || !!pending.rune; pendingBadge.style.display = hasPending ? 'block' : 'none';
  }

  function rerender(){ renderBoard(); renderSidebar(); }

  /*__INIT_MV__*/
  try{ const cur = state.turn; for (const p of Object.values(pawns)) p.mv = (p.owner===cur)?1:0; }catch(e){}

  // Dragging logic (pawns)
  function startPawnDrag(ev, pawnId){
    const me = state.turn;
    if (state.gameStarted && (state.players[me].timeMs <= 0)) return;
    try{
      const pid = typeof pawnId!=='undefined' ? pawnId : arguments[1];
      const p = pawns && pawns[pid];
      if ((pending.pawnMoves||[]).length >= 4) return;
      if (p && (p.mv||0) <= 0) return;
      if (p && p.captured) return; // why: cannot drag captured pawn
    }catch(e){}
    if (state.turn !== pawns[pawnId].owner) return;
    dragging = { kind: 'pawn', id: pawnId };
    dragPoint = svgPoint(ev);
    dragPreviewTarget = null;
    svg.setPointerCapture(ev.pointerId);
    svg.addEventListener('pointermove', onPawnMove);
    svg.addEventListener('pointerup', endPawnDrag, { once: true });
    rerender();
  }
  function onPawnMove(ev){
    dragPoint = svgPoint(ev);
    const pawn = pawns[dragging.id]; const fromNode = nodeForPawn(pawn.id);
    if (!fromNode) return;
    let best=null, bestD=Infinity;
    for (const nid of fromNode.neighbors){ const n=nodes[nid]; const dx=n.pos.x-dragPoint.x, dy=n.pos.y-dragPoint.y; const d=dx*dx+dy*dy; if (d<bestD){bestD=d; best=nid;} }
    dragPreviewTarget = (best && bestD<70*70) ? best : null;
    renderBoard();
  }
  function endPawnDrag(ev){
    svg.releasePointerCapture(ev.pointerId);
    svg.removeEventListener('pointermove', onPawnMove);
    if (dragPreviewTarget){
      const pawn = pawns[dragging.id];
      const others = pending.pawnMoves.filter(m=>m.pawnId!==pawn.id);
      const proposed = [...others, { pawnId: pawn.id, to: dragPreviewTarget }];
      if (proposed.length <= 4){
        previewEdges[pawn.id] = dragPreviewTarget;
        pending.pawnMoves = proposed;
        try{ if (pawns[pawn.id]) pawns[pawn.id].mv = 0; }catch(e){}
      }
    }
    dragging = null; dragPreviewTarget = null; rerender();
  }

  // Dragging logic (runes)
  function startRuneDrag(ev, cardId, owner){
    const me = state.turn;
    if (state.gameStarted && (state.players[me].timeMs <= 0)) return;
    try{
      const curMp = (state.players[me].mp||0);
      if (!(curMp >= 2 || pending.rune)){ return; }
    }catch(e){}    
    if (state.turn !== owner) return;
    dragging = { kind:'rune', id: cardId, owner };
    dragPoint = svgPoint(ev);
    dragPreviewTarget = null;
    svg.setPointerCapture(ev.pointerId);
    svg.addEventListener('pointermove', onRuneMove);
    svg.addEventListener('pointerup', endRuneDrag, { once: true });
    rerender();
  }
  function onRuneMove(ev){
    dragPoint = svgPoint(ev);
    let best=null, bestD=Infinity;
    for (const id of cellList){
      const ctr = centers[id]; const dx=ctr.x-dragPoint.x, dy=ctr.y-dragPoint.y; const d=dx*dx+dy*dy;
      if (d<bestD){bestD=d; best=id;}
    }
    dragPreviewTarget = best; renderBoard();
  }
  function endRuneDrag(ev){
    svg.releasePointerCapture(ev.pointerId);
    svg.removeEventListener('pointermove', onRuneMove);

    if (dragPreviewTarget) {
      const ownerKey = dragging.owner;
      const targetCell = dragPreviewTarget;

      if (isRunePlacementLegal(targetCell, ownerKey)) {
        pending.rune = { cardId: dragging.id, cellId: targetCell };
        try {
          const me = state.turn;
          if (!pending.runeMpSpent && (state.players[me].mp || 0) >= 2) {
            state.players[me].mp = 0;
            pending.runeMpSpent = true;
          }
        } catch (e) {}
      } else {
        logEvent(`${ownerKey} tried to place a rune on ${targetCell}, but it is not on a hex touched by their pawns this turn.`);
      }
    }

    dragging = null; rerender();
  }

  // Rune click handling
  function handleRuneClick(index, ev){
    if (state.gameStarted && state.players[state.turn].timeMs <= 0) return;

    const rune = state.placedRunes[index];
    if (!rune) return;

    const currentPlayerKey = state.turn;
    if (rune.owner !== currentPlayerKey) return;

    const player = state.players[currentPlayerKey];
    const card = cards[rune.cardId];
    if (!card) return;

    const effect = RUNE_EFFECTS[card.code];
    const cost = effect ? (effect.costMp || 0) : 0;

    if (rune.exhausted){
      return handleRuneRecharge(rune, index, ev);
    }

    if (cost > 0 && (player.mp || 0) < cost){
      logEvent(`${currentPlayerKey} tried to activate ${card.code} but lacks magic.`);
      return;
    }

    if (cost > 0) player.mp -= cost;

    if (effect && typeof effect.activate === 'function'){
      effect.activate(state, {
        rune,
        placedIndex: index,
        player,
        playerKey: currentPlayerKey,
        pawns,
        nodes,
        centers,
        log: logEvent,
        svg
      });
    } else {
      logEvent(`${currentPlayerKey} activated ${card.code} at ${rune.cellId}.`);
    }

    rune.exhausted = true;
    rune.angle = ((rune.angle || 0) + 90) % 360;

    rerender();
  }

  function handleRuneRecharge(rune, index, ev){
    const currentPlayerKey = state.turn;
    if (rune.owner !== currentPlayerKey) return;

    const player = state.players[currentPlayerKey];
    if ((player.mp || 0) < 1){
      logEvent(`${currentPlayerKey} tried to recharge ${cards[rune.cardId].code} but has no magic.`);
      return;
    }

    player.mp -= 1;
    rune.exhausted = false;
    rune.angle = 0;

    logEvent(`${currentPlayerKey} recharged ${cards[rune.cardId].code} at ${rune.cellId}.`);

    rerender();
  }

  // ---- Respawn helpers ----
  const START_VERTS = {
    ORANGE: topVerts.map(v => v.id),
    BLUE:   botVerts.map(v => v.id)
  };
  function respawnCapturedPawnsForCurrentPlayer(){
    const me = state.turn;
    const starts = START_VERTS[me] || [];
    const occ = new Set(
      Object.values(pawns)
        .filter(p => !p.captured && p.edge)
        .map(p => p.edge)
    );

    for (const p of Object.values(pawns)) {
      if (p.owner !== me || !p.captured) continue;

      if (p.skipOwnTurns > 0) {
        p.skipOwnTurns -= 1;
        continue; // still waiting
      }

      // Time to respawn
      let target = null;
      if (p.startEdge && !occ.has(p.startEdge)) {
        target = p.startEdge;
      } else {
        for (const s of starts) {
          if (!occ.has(s)) { target = s; break; }
        }
      }

      if (!target) {
        // No free starting spots – remain captured
        continue;
      }

      // Place pawn on starting vertex
      p.edge = target;
      p.captured = false;
      p.skipOwnTurns = 0;
      occ.add(target);

      // Respawning counts as this pawn's move this turn
      p.mv = 0;

      logEvent(`${me} pawn ${p.id} respawned at starting vertex ${target}.`);
    }
  }

  // Commit turn (+30s bonus, capture, respawn)
  function endTurn(){
    const me = state.turn;
    if (pending.pawnMoves.length>4){ return; }

    // Unique pawn per move
    const perPawn = new Set(pending.pawnMoves.map(m=>m.pawnId));
    if (perPawn.size !== pending.pawnMoves.length){ return; }

    // Build occupancy index excluding captured pawns
    const nodeOccupants = {};
    for (const p of Object.values(pawns)) {
      if (!p.captured && p.edge) {
        if (!nodeOccupants[p.edge]) nodeOccupants[p.edge] = [];
        nodeOccupants[p.edge].push(p.id);
      }
    }

    const capturesThisTurn = [];

    // Validate staged moves with capture rules
    for (const m of pending.pawnMoves){
      const pawn = pawns[m.pawnId];
      if (!pawn || pawn.owner !== me || pawn.captured) return;

      const fromNode = pawn.edge;
      const toNode = m.to;

      if (!nodes[fromNode]?.neighbors.includes(toNode)) return;

      // Current occupants on destination (alive only)
      const occ = (nodeOccupants[toNode] || []).filter(pid => !pawns[pid].captured);
      const sameColor = occ.filter(pid => pawns[pid].owner === me);
      const enemy = occ.filter(pid => pawns[pid].owner !== me);

      // Is same-color pawn at dest also moving away?
      const alsoMovingAway = pending.pawnMoves.some(x => x.pawnId !== m.pawnId && pawns[x.pawnId].edge === toNode);

      // Forbid stacking on own pawn unless that pawn is leaving
      if (sameColor.length > 0 && !alsoMovingAway) {
        return;
      }

      // Mark enemy for capture
      if (enemy.length > 0) {
        for (const eid of enemy) {
          capturesThisTurn.push({ victimId: eid, byId: m.pawnId, dest: toNode });
        }
      }

      // Virtually move the attacker for subsequent validations
      nodeOccupants[toNode] = nodeOccupants[toNode] || [];
      if (!nodeOccupants[toNode].includes(m.pawnId)) {
        nodeOccupants[toNode].push(m.pawnId);
      }
      if (nodeOccupants[fromNode]) {
        nodeOccupants[fromNode] = nodeOccupants[fromNode].filter(pid => pid !== m.pawnId);
      }
    }

    // Commit moves
    for (const m of pending.pawnMoves){ pawns[m.pawnId].edge = m.to; delete previewEdges[m.pawnId]; }

    // Persist rune placement (unchanged)
    if (pending.rune && pending.rune.cardId && pending.rune.cellId){
      const meOwner = state.turn;
      state.placedRunes.push({
        cardId: pending.rune.cardId,
        cellId: pending.rune.cellId,
        owner: meOwner,
        angle: 0,
        exhausted: false
      });
      try {
        const h = state.players[meOwner].hand;
        state.players[meOwner].hand = h.filter(id => id !== pending.rune.cardId);
      } catch(e) {}
    }
    if (pending.rune){ const hand = state.players[me].hand; state.players[me].hand = hand.filter(id=>id!==pending.rune.cardId); }

    // Apply captures after all movement is committed
    pending.captures = capturesThisTurn || [];
    for (const c of pending.captures) {
      const victim = pawns[c.victimId];
      if (!victim || victim.captured) continue;

      victim.captured = true;
      victim.edge = null;            // off-board
      victim.skipOwnTurns = 1;       // skip next own turn before respawn

      logEvent(`${victim.owner} pawn ${victim.id} was captured by ${pawns[c.byId].owner} pawn ${c.byId}.`);
    }

    // Time handling – AFTER subtracting elapsed, THEN give +30s, BEFORE switching turn
    const now = Date.now();
    if (state.gameStarted){
      const elapsed = now - lastTurnAt;
      state.players[me].timeMs = Math.max(0, state.players[me].timeMs - elapsed);
      const BONUS = 30 * 1000; // 30 seconds in ms
      state.players[me].timeMs += BONUS;
    }
    lastTurnAt = now;

// Switch turn
state.turn = me === 'ORANGE' ? 'BLUE' : 'ORANGE';
state.turnCount += 1;

// Magic reset
resetAllMagic();

// Set mv for new turn FIRST
try {
  const cur = state.turn;
  for (const p of Object.values(pawns)) {
    p.mv = (p.owner === cur && !p.captured) ? 1 : 0;
  }
} catch (e) {}

// Respawn AFTER mv reset (respawn already sets p.mv = 0)
respawnCapturedPawnsForCurrentPlayer();


    const runeText = pending.rune ? ` and placed ${cards[pending.rune.cardId].code} on ${pending.rune.cellId}` : '';
    logEvent(`${me} moved ${pending.pawnMoves.length} pawn(s)${runeText}.`);

    pending.pawnMoves = [];
    safeClearPendingRune();
    pending.runeMpSpent = false;
    pending.captures = [];
    dragPreviewTarget=null;
    rerender(); updateClocks();
  }

  document.getElementById('undoBtn').addEventListener('click', undoLast);
  document.getElementById('endTurn').addEventListener('click', endTurn);
  document.getElementById('resetPending').addEventListener('click', ()=>{ pending.pawnMoves = []; safeClearPendingRune(); pending.runeMpSpent = false; dragPreviewTarget=null; for (const k in previewEdges) delete previewEdges[k]; rerender(); });

  // clocks
  let lastTurnAt = Date.now();
  const cO = document.getElementById('clock-orange'), cB = document.getElementById('clock-blue');
  const fmt = ms => { const s=Math.max(0,Math.floor(ms/1000)); const m=Math.floor(s/60), ss=(s%60).toString().padStart(2,'0'); return `${m}:${ss}`; };
  function updateClocks(){ cO.textContent = fmt(state.players.ORANGE.timeMs); cB.textContent = fmt(state.players.BLUE.timeMs); }

  setInterval(()=>{
    const me = state.turn;
    const now = Date.now();
    let tO = state.players.ORANGE.timeMs;
    let tB = state.players.BLUE.timeMs;
    if (state.gameStarted){
      const elapsed = now - lastTurnAt;
      if (me === 'ORANGE') tO = Math.max(0, tO - elapsed);
      else tB = Math.max(0, tB - elapsed);
    }
    cO.textContent = fmt(tO); cB.textContent = fmt(tB);
  }, 250);

  function startGame(){
    const baseTime = 10 * 60 * 1000;
    state.players.ORANGE.timeMs = baseTime;
    state.players.BLUE.timeMs = baseTime;

    // Reset pieces to starting positions (pawns only; minimal per spec)
    for (const p of Object.values(pawns)){
      // why: guarantee clean start state including captures
      p.captured = false;
      p.skipOwnTurns = 0;
      if (p.startEdge) p.edge = p.startEdge;
      p.mv = (p.owner==='ORANGE') ? 1 : 0;
    }
    for (const k in previewEdges) delete previewEdges[k];
    pending.pawnMoves = [];
    safeClearPendingRune();
    pending.runeMpSpent = false;
    pending.captures = [];

    state.turn = 'ORANGE';
    state.turnCount = 0;
    lastTurnAt = Date.now();
    state.gameStarted = true;

    resetAllMagic();

    logEvent('Game started. ORANGE to move. Pieces reset to starting vertices.');
    rerender();
    updateClocks();
  }
  document.getElementById('startGame').addEventListener('click', startGame);

  rerender(); updateClocks();

  function undoLast(){
    if (pending.rune){
      try{ if (pending.runeMpSpent){ const me = state.turn; state.players[me].mp = state.players[me].mpMax || MP_MAX; pending.runeMpSpent = false; } }catch(e){}
      pending.rune = null;
      rerender(); return;
    }
    if (pending.pawnMoves && pending.pawnMoves.length>0){
      const last = pending.pawnMoves.pop();
      try{ delete previewEdges[last.pawnId]; }catch(e){}
      try{ if (pawns[last.pawnId]) pawns[last.pawnId].mv = 1; }catch(e){}
      rerender(); return;
    }
  }

})();
</script>

<!-- SAFE HOOK: persistent runes + per-pawn move limit -->
<script>
/* Intentionally left inert; authoritative logic is in the main script. */
(function(){})();
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Runez — v11 (C#R# 4–5–4–5–4 honeycomb, rotated)</title>
<style>
  :root{--boardGray:#6e5236;--edge:#2f2317;--gold:#c3a13a;--silver:#b9c0c6;--goldDeep:#9f8126;--silverDeep:#8e959e;--woodA:#2b2016;--woodB:#3b2d20;--woodC:#5a422d;--woodD:#7a5a3c;--accent:#8e5e2e;}
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,'Helvetica Neue',Arial;}
  body{display:grid;grid-template-rows:auto 1fr auto;background:radial-gradient(120% 120% at 50% 0%, rgba(0,0,0,0.15), rgba(0,0,0,0)),linear-gradient(90deg, rgba(60,45,33,0.35) 0 1px, rgba(255,255,255,0) 1px) 0 0/16px 100%,repeating-linear-gradient(0deg,var(--woodD),var(--woodC) 24px,var(--woodB) 48px,var(--woodA) 72px);color:#eae3d7;}
  header,footer{padding:12px 18px;border-bottom:1px solid #5b4a37;background:linear-gradient(180deg, rgba(0,0,0,0.2), rgba(0,0,0,0)), repeating-linear-gradient(90deg, rgba(255,255,255,0.04), rgba(255,255,255,0.04) 2px, transparent 2px, transparent 6px);}
  footer{border-top:1px solid #5b4a37;border-bottom:none;display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  main{display:grid;grid-template-columns:1fr 420px;gap:18px;padding:18px;min-height:0;}
  @media (max-width: 1280px){ main{grid-template-columns:1fr;} }
  #boardWrap{border:1px solid #a6885e;border-radius:16px;overflow:auto;position:relative;height:800px;min-height:800px;max-width:100%;background:radial-gradient(130% 90% at 50% 10%, rgba(0,0,0,0.12), rgba(0,0,0,0)), linear-gradient(90deg, rgba(80,58,39,0.28) 0 1px, rgba(255,255,255,0) 1px) 0 0/16px 100%,repeating-linear-gradient(0deg,#e9d2aa,#e1c394 24px,#d8b781 48px,#d0ab74 72px);}#boardWrap:before,#boardWrap:after{content:'';position:absolute;width:26px;height:26px;border:2px solid #a6885e;border-radius:4px;opacity:.8;}#boardWrap:before{left:10px;top:10px;border-right:none;border-bottom:none;}#boardWrap:after{right:10px;bottom:10px;border-left:none;border-top:none;}
  #sidebar{border:1px solid #7a5a3c;border-radius:16px;padding:12px;display:grid;gap:12px;height:100%;min-height:0;background:linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0)), repeating-linear-gradient(0deg,#5a422d,#4a3726 28px,#3f2e21 56px);}
  .stack{display:grid;gap:8px;}
  .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .stat{border:1px solid #826444;border-radius:12px;padding:10px;text-align:center;min-width:100px;background:linear-gradient(180deg, rgba(255,255,255,0.04), rgba(0,0,0,0));}
  .btn{padding:10px 14px;border-radius:10px;border:1px solid #b99357;background:linear-gradient(180deg,#b99357,#8b6d3e);color:#20170e;cursor:pointer;box-shadow:inset 0 1px 0 rgba(255,255,255,0.3);}
  .btn.ghost{background:linear-gradient(180deg,#685035,#4f3c2a);color:#f1e7d6;border-color:#8a6a46;}
  .log{height:180px;overflow:auto;border:1px solid #6f5338;border-radius:12px;padding:8px;background:linear-gradient(180deg, rgba(255,255,255,0.04), rgba(0,0,0,0));font-size:14px;}
  svg{touch-action:none; display:block; margin:auto; background:linear-gradient(90deg, rgba(60,45,33,0.18) 0 1px, rgba(255,255,255,0) 1px) 0 0/16px 100%,repeating-linear-gradient(0deg,#e2c298,#d9b583 24px,#d0a871 48px,#c99e67 72px);}
  .hint{fill:#22c55e;opacity:.2}
  .focusRing:focus{outline:2px solid #3b82f6;outline-offset:2px;border-radius:6px}
  .card{width:50px;height:76px;border-radius:8px;border:1px solid #333;display:flex;align-items:center;justify-content:center;user-select:none;font-size:26px}
  .card.gold{background:linear-gradient(180deg, var(--gold), var(--goldDeep));color:#2a230f;box-shadow:inset 0 1px 0 rgba(255,255,255,0.4);} .card.silver{background:linear-gradient(180deg, var(--silver), var(--silverDeep));color:#151922;box-shadow:inset 0 1px 0 rgba(255,255,255,0.4);}
  .chip{display:inline-flex;align-items:center;gap:8px}
  .gallery{display:flex;flex-wrap:wrap;gap:10px;justify-content:center;padding:18px 14px;border-top:1px solid #a6885e;background:linear-gradient(90deg, rgba(60,45,33,0.2) 0 1px, rgba(255,255,255,0) 1px) 0 0/16px 100%,repeating-linear-gradient(0deg,#dcc093,#d2b381 24px,#caa873 48px,#c39f6a 72px);}
  .gallery h4{flex-basis:100%;margin:6px 0 0 0;text-align:center;font-weight:600}
  .cardTall{width:52px;height:82px}
  .pendingBadge{position:absolute;right:12px;bottom:12px;background:#f59e0b;color:white;padding:6px 10px;border-radius:999px;font-size:12px}
  .coords{font-size:12px; fill:#111; opacity:.6; pointer-events:none}

  .panelGold{background:linear-gradient(180deg, rgba(195,161,58,0.22), rgba(159,129,38,0.12)); border-color:#b89a4c;}
  .panelSilver{background:linear-gradient(180deg, rgba(185,192,198,0.22), rgba(142,149,158,0.12)); border-color:#9ea6ad;}
  .handPanel{padding:6px;border:1px solid transparent;border-radius:10px;font-size:14px;}
  .statGold{background:linear-gradient(180deg, rgba(195,161,58,0.18), rgba(159,129,38,0.10)); border-color:#b89a4c;}
  .statSilver{background:linear-gradient(180deg, rgba(185,192,198,0.18), rgba(142,149,158,0.10)); border-color:#9ea6ad;}


  .mpdots{ display:flex; gap:8px; align-items:center; justify-content:center; }
  .mpDot{ width:16px; height:16px; border-radius:50%; border:2px solid #fff; background:transparent; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.25); }
  .mpDot.filled{ background:#fff; }
</style>
</head>
<body>
<header>
  <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
    <div class="chip"><strong>Gold</strong> ⏱ <span id="clock-orange">10:00</span></div>
    <div class="chip"><strong>Silver</strong> ⏱ <span id="clock-blue">10:00</span></div>
  </div>
</header>
<main>
  <div id="boardWrap">
    <svg id="board" role="application" aria-label="Runez board"></svg>
    <div id="gallery-blue" class="row" style="justify-content:center;width:100%"></div>
    </div>
<div id="gallery" class="gallery">
      <h4>Full 24 Rune Decks</h4>
      <div id="gallery-orange" class="row" style="justify-content:center;width:100%"></div>
      

    <div id="pendingBadge" class="pendingBadge" style="display:none">Pending moves…</div>
  </div>
  <aside id="sidebar">
    <section class="stack handPanel" id="hand-panel">
      <h3 style="margin:4px 0">Your Hand (<span id="hand-owner">ORANGE</span>)</h3>
      <div class="row" id="hand"></div>
    </section>
    <section class="row">
      <div class="stat" id="stat-deck-me"><div>Your Deck</div><div style="font-size:20px" id="deck-me">—</div></div>
      <div class="stat" id="stat-discard-me"><div>Discard</div><div style="font-size:20px" id="discard-me">—</div></div>
      <div class="stat" id="stat-deck-opp"><div>Opp. Deck</div><div style="font-size:20px" id="deck-opp">—</div></div>
    </section>
    <section class="row">
      <div class="stat panelSilver" id="stat-mp-me"><div>Magic</div><div id="mp-me" class="mpdots"></div></div>
      <div class="stat" id="stat-mp-opp"><div>Opp. Magic</div><div id="mp-opp" class="mpdots"></div></div>
    </section>
    <section class="stack">
      <h3 style="margin:4px 0">Move Log</h3>
      <div class="log" id="log"></div>
    </section>
  </aside>
</main>
<footer>
  <button id="undoBtn" class="btn ghost">Undo</button>
  <button id="endTurn" class="btn">End Turn</button>
  <button id="resetPending" class="btn ghost">Reset pending</button>
  <span style="opacity:.7">22 cells, tight pointy-top honeycomb. Pawns placed per your C#R# list.</span>
</footer>

<script>
(() => {
  // 24 rune deck (visual only)
  const ELDER_24 = [
    {code:'FEHU',    sym:'ᚠ'},{code:'URUZ',   sym:'ᚢ'},{code:'THURISAZ',sym:'ᚦ'},{code:'ANSUZ', sym:'ᚨ'},
    {code:'RAIDHO',  sym:'ᚱ'},{code:'KAUNA',  sym:'ᚲ'},{code:'GEBO',    sym:'ᚷ'},{code:'WUNJO', sym:'ᚹ'},
    {code:'HAGALAZ', sym:'ᚺ'},{code:'NAUDIZ', sym:'ᚾ'},{code:'ISAZ',    sym:'ᛁ'},{code:'JERA',  sym:'ᛃ'},
    {code:'EIHWAZ',  sym:'ᛇ'},{code:'PERTHRO',sym:'ᛈ'},{code:'ALGIZ',   sym:'ᛉ'},{code:'SOWILO',sym:'ᛋ'},
    {code:'TIWAZ',   sym:'ᛏ'},{code:'BERKANO',sym:'ᛒ'},{code:'EHWAZ',   sym:'ᛖ'},{code:'MANNAZ',sym:'ᛗ'},
    {code:'LAGUZ',   sym:'ᛚ'},{code:'INGWAZ', sym:'ᛜ'},{code:'DAGAZ',   sym:'ᛞ'},{code:'OTHALA',sym:'ᛟ'},
  ];

  // --- Geometry: pointy-top honeycomb, 5 rows (levels) with alternating horizontal offsets ---
  const size = 72; // big tiles
  const h = size;                       // radius along pointy axis
  const w = Math.sqrt(3) * size;        // width corner to corner
  const vStep = 1.5 * size;             // vertical distance between rows
  const xStep = w;                       // horizontal spacing between same-row neighbors
  const rowOffset = 0.5 * w;             // half shift for even rows

  // Column definitions and labels
  const columns = {
    1: 4, 2: 5, 3: 4, 4: 5, 5: 4
  };

  // Build cells following your layout visualization
  const cells = {};           // id -> {id,label,col,row,center} 
  const centers = {};         // id -> {x,y}
  const cellList = [];        // ordered list
  const levels = [1,2,3,4,5]; // top to bottom

  // We'll place positions by rows (levels). For each level, compute x start with row offset.
  // Map presence by your spec:
  // Level 1: C1R1..C5R1
  // Level 2: C1R2..C5R2
  // Level 3: C1R3..C5R3
  // Level 4: C1R4..C5R4
  // Level 5: C2R5 and C4R5 only
  const present = new Set([
    'C1R1','C2R1','C3R1','C4R1','C5R1',
    'C1R2','C2R2','C3R2','C4R2','C5R2',
    'C1R3','C2R3','C3R3','C4R3','C5R3',
    'C1R4','C2R4','C3R4','C4R4','C5R4',
    'C2R5','C4R5'
  ]);

  const svg = document.getElementById('board');

  

function placeCells(){
  // TRUE tessellation: flat-top odd-q grid with manual shift for C2 and C4 upwards
  const S = size;
  const rt3 = Math.sqrt(3);
  const heights = [4,5,4,5,4];
  const svg = document.getElementById('board');

  for (const k of Object.keys(centers)) delete centers[k];
  cellList.length = 0;

  const padX = 130, padY = 200;
  let maxX = 0, maxY = 0;

  for (let q=1; q<=5; q++){
    const hq = heights[q-1];
    for (let r=1; r<=hq; r++){
      const id = `C${q}R${r}`;
      let cx = padX + 1.5*S*(q-1);
      let cy = padY + rt3*S*((r-1) + 0.5*((q-1)%2));
      // Push columns 2 and 4 UP by one hex height
      if (q===2 || q===4){
        cy -= rt3*S;
      }
      centers[id] = { x: cx, y: cy };
      cells[id] = cells[id] || { id, col: q, row: r };
      cellList.push(id);
      if (cx>maxX) maxX=cx; if (cy>maxY) maxY=cy;
    }
  }

  const pad = S*2;
  const width  = Math.max(1200, Math.ceil(maxX + pad));
  const height = Math.max(900,  Math.ceil(maxY + pad));
  svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
  svg.setAttribute('width',  Math.min(1800, width));
  svg.setAttribute('height', Math.min(1200, height));

  return { width, height };
}



  // Build edges graph: midpoints between neighboring hex centers (edge-sharing)
  const edges = {}; // id -> {id,pos,neighbors:[]}
  function addNode(id,pos){ if(!edges[id]) edges[id] = { id, pos:{...pos}, neighbors:[] }; return edges[id]; }
  function connect(a,b){ if(!a.neighbors.includes(b.id)) a.neighbors.push(b.id); if(!b.neighbors.includes(a.id)) b.neighbors.push(a.id); }

  function hexPolygon(center, R=size){
  const pts=[];
  for (let i=0;i<6;i++){
    const ang = (Math.PI/3)*i; // flat-top
    pts.push([center.x + R*Math.cos(ang), center.y + R*Math.sin(ang)]);
  }
  return pts;
}


function buildGraph(){
  // Build a vertex graph: nodes at hex *corners*; edges along hex sides (vertex-to-vertex).
  // Reset edges
  for (const k of Object.keys(edges)) delete edges[k];

  // Dedup helper: bucket coordinates to merge shared vertices between neighboring hexes
  const nodeMap = new Map();
  const getKey = (x,y) => `${Math.round(x/0.75)}:${Math.round(y/0.75)}`;
  const getNode = (x,y) => {
    const k = getKey(x,y);
    if (!nodeMap.has(k)){
      const id = `v${nodeMap.size.toString().padStart(4,'0')}`;
      nodeMap.set(k, id);
      edges[id] = { id, pos: {x,y}, neighbors: [] };
    }
    return edges[nodeMap.get(k)];
  };
  const connect = (a,b) => {
    if (a.id===b.id) return;
    if (!a.neighbors.includes(b.id)) a.neighbors.push(b.id);
    if (!b.neighbors.includes(a.id)) b.neighbors.push(a.id);
  };

  // For each hex, add its 6 vertices and connect a 6-cycle
  for (const id of Object.keys(centers)){
    const verts = hexPolygon(centers[id], size); // [[x,y],...]
    const nodes = verts.map(([x,y]) => getNode(x,y));
    for (let i=0;i<6;i++){
      const a = nodes[i], b = nodes[(i+1)%6];
      connect(a,b);
    }
  }
}
// ---- Place board ----

  const dims = placeCells();
  buildGraph();

  
// Pawn placement: place 4 Gold on top vertices, 4 Silver on bottom vertices
const pawns = {};
let oid=0,bid=0;

// Find extreme Y vertices
const allNodes = Object.values(edges);
const minY = Math.min(...allNodes.map(n=>n.pos.y));
const maxY = Math.max(...allNodes.map(n=>n.pos.y));

// Get 4 closest vertices to left→right order at minY and maxY
function getExtremeVertices(targetY, count){
  const band = allNodes.filter(n => Math.abs(n.pos.y - targetY) < 20);
  // sort left-to-right
  band.sort((a,b)=>a.pos.x-b.pos.x);
  return band.slice(0,count);
}
const topVerts = getExtremeVertices(minY,4);
const botVerts = getExtremeVertices(maxY,4);

// Assign pawns
for (const n of topVerts){
  const id = `O${oid++}`;
  pawns[id] = { id, owner:'ORANGE', edge:n.id };
}
for (const n of botVerts){
  const id = `B${bid++}`;
  pawns[id] = { id, owner:'BLUE', edge:n.id };
}
 
// --- Game-ish state ---

  const MP_MAX = 2;
  const state = {
  placedRunes: [],
    players: {
      ORANGE: { color:'ORANGE', pawns: Object.keys(pawns).filter(id=>id.startsWith('O')), deck: [], hand: [], discard: [], timeMs: 10*60*1000, name:'Gold' , mp: MP_MAX, mpMax: MP_MAX},
      BLUE:   { color:'BLUE',   pawns: Object.keys(pawns).filter(id=>id.startsWith('B')), deck: [], hand: [], discard: [], timeMs: 10*60*1000, name:'Silver'   , mp: MP_MAX, mpMax: MP_MAX},
    },
    turn: 'ORANGE',
    log: [{ t: Date.now(), text: 'v11 honeycomb ready. Orange to move.' }],
  };

  // hand = all 24 for side to move
  function makeDeck(owner){
    const order=[], cards={};
    for (let i=0;i<24;i++){ const id=`${owner}-card-${i}`; cards[id]={id,owner,code:ELDER_24[i].code,sym:ELDER_24[i].sym}; order.push(id); }
    return { cards, order };
  }
  const deckO = makeDeck('ORANGE'), deckB = makeDeck('BLUE');
  const cards = { ...deckO.cards, ...deckB.cards };
  state.players.ORANGE.hand = deckO.order.slice(0,24);
  state.players.BLUE.hand   = deckB.order.slice(0,24);

  function grantMagic(who, amt=1){
    const p = state.players[who]; if (!p) return;
    p.mp = Math.min((p.mp||0) + amt, p.mpMax||MP_MAX); rerender();
  }
  function spendMagic(who, amt=1){
    const p = state.players[who]; if (!p) return false;
    if ((p.mp||0) < amt) return false;
    p.mp -= amt; rerender(); return true;
  }
  function resetAllMagic(){
    state.players.ORANGE.mp = state.players.ORANGE.mpMax || MP_MAX;
    state.players.BLUE.mp   = state.players.BLUE.mpMax   || MP_MAX;
  }

  const pending = { pawnMoves: [], rune: null, runeMpSpent: false };
  function safeClearPendingRune(){ try{ if (pending.rune && pending.runeMpSpent){ const me = state.turn; state.players[me].mp = state.players[me].mpMax || MP_MAX; pending.runeMpSpent = false; } }catch(e){} pending.rune = null; }
  const previewEdges = {};
  const pendingBadge = document.getElementById('pendingBadge');

  const galleryO = document.getElementById('gallery-orange');
  const galleryB = document.getElementById('gallery-blue');
  const handEl = document.getElementById('hand');
  const logEl = document.getElementById('log');
  const deckMe = document.getElementById('deck-me');
  const discardMe = document.getElementById('discard-me');
  const deckOpp = document.getElementById('deck-opp');
  const statDiscard = document.getElementById('stat-discard-me');
  const statOpp = document.getElementById('stat-deck-opp');
  const handOwnerLabel = document.getElementById('hand-owner');

  for (let i=0;i<24;i++){
    const o = document.createElement('div'); o.className='card cardTall gold'; o.textContent=ELDER_24[i].sym; o.title=ELDER_24[i].code; galleryO.appendChild(o);
  }
  for (let i=0;i<24;i++){
    const b = document.createElement('div'); b.className='card cardTall silver'; b.textContent=ELDER_24[i].sym; b.title=ELDER_24[i].code; galleryB.appendChild(b);
  }

  function polyPoints(center,R=size){
  const pts=[];
  for (let i=0;i<6;i++){
    const ang = (Math.PI/3)*i; // flat-top
    pts.push(`${center.x + R*Math.cos(ang)},${center.y + R*Math.sin(ang)}`);
  }
  return pts.join(' ');
}

// Build neighbor visualization (optional), place runes, pawns, drag/snap like before
  const nodes = edges; // alias

  function svgPoint(evt){
    const pt = svg.createSVGPoint(); pt.x = evt.clientX; pt.y = evt.clientY;
    const m = svg.getScreenCTM().inverse(); const p = pt.matrixTransform(m);
    return { x: p.x, y: p.y };
  }

  function nodeForPawn(pawnId){ return nodes[ previewEdges[pawnId] || pawns[pawnId].edge ]; }

  let dragging = null; // {kind:'pawn'|'rune', id, owner?}
  let dragPoint = { x: 0, y: 0 };
  let dragPreviewTarget = null;

  function drawRuneAt(x,y,isOrange,sym,opacity){
    const r = document.createElementNS('http://www.w3.org/2000/svg','rect');
    r.setAttribute('x', x-24); r.setAttribute('y', y-34); r.setAttribute('width','48'); r.setAttribute('height','68'); r.setAttribute('rx','5');
    r.setAttribute('fill', isOrange? (getComputedStyle(document.documentElement).getPropertyValue('--gold').trim()||'#C8A949'):(getComputedStyle(document.documentElement).getPropertyValue('--silver').trim()||'#C0C0C8')); r.setAttribute('stroke','#333'); r.setAttribute('opacity', String(opacity));
    const t = document.createElementNS('http://www.w3.org/2000/svg','text');
    t.setAttribute('x', x); t.setAttribute('y', y+8); t.setAttribute('text-anchor','middle'); t.setAttribute('font-size','26');
    t.setAttribute('fill', isOrange? '#3e2f20':'#1f2430'); t.textContent = sym;
    svg.appendChild(r); svg.appendChild(t);
  }

  function renderBoard(){
    svg.innerHTML = '';
    // draw cells
    for (const id of cellList){
      const ctr = centers[id];
      const poly = document.createElementNS('http://www.w3.org/2000/svg','polygon');
      poly.setAttribute('points', polyPoints(ctr));
      poly.setAttribute('fill', getComputedStyle(document.documentElement).getPropertyValue('--boardGray').trim() || '#6e5236');
      poly.setAttribute('stroke', '#4b3a28'); poly.setAttribute('stroke-width','2');
      svg.appendChild(poly);

      // label C#R#
      const label = document.createElementNS('http://www.w3.org/2000/svg','text');
      label.setAttribute('x', ctr.x); label.setAttribute('y', ctr.y+6);
      label.setAttribute('text-anchor','middle'); label.setAttribute('class','coords'); label.textContent = id;
      svg.appendChild(label);

      if (dragging?.kind==='rune' && state.turn===dragging.owner){
        const hint = document.createElementNS('http://www.w3.org/2000/svg','circle');
        hint.setAttribute('cx', ctr.x); hint.setAttribute('cy', ctr.y); hint.setAttribute('r','30'); hint.setAttribute('class','hint');
        svg.appendChild(hint);
      }
    }

    // pending rune ghost
    if (pending.rune && centers[pending.rune.cellId]){
      const ctr = centers[pending.rune.cellId]; const isOrange = pending.rune.cardId.startsWith('ORANGE');
      drawRuneAt(ctr.x, ctr.y, isOrange, cards[pending.rune.cardId].sym, 0.9);
    }

    // soft edge graph dots
    for (const e of Object.values(nodes)){
      const dot = document.createElementNS('http://www.w3.org/2000/svg','circle');
      dot.setAttribute('cx', e.pos.x); dot.setAttribute('cy', e.pos.y); dot.setAttribute('r','3'); dot.setAttribute('fill','#000'); dot.setAttribute('opacity','0.07');
      svg.appendChild(dot);
    }

    // highlights while dragging a pawn
    if (dragging?.kind==='pawn'){
      const p = pawns[dragging.id]; const n = nodeForPawn(p.id);
      for (const nid of n.neighbors){
        const nb = nodes[nid];
        const hi = document.createElementNS('http://www.w3.org/2000/svg','circle');
        hi.setAttribute('cx', nb.pos.x); hi.setAttribute('cy', nb.pos.y); hi.setAttribute('r','14'); hi.setAttribute('class','hint');
        svg.appendChild(hi);
      }
    }

    
    
    /*__PERSISTED_RUNES__*/
    if (Array.isArray(state.placedRunes)){
      state.placedRunes.forEach((pr, i) => {
        const ctr = centers[pr.cellId];
        const card = cards[pr.cardId];
        if (!ctr || !card) return;
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        const angle = (pr.angle || 0);
        g.setAttribute('transform', `rotate(${angle} ${ctr.x} ${ctr.y})`);
        g.style.cursor = 'pointer';
        g.addEventListener('click', () => {
          try{
            const item = state.placedRunes[i];
            item.angle = ((item.angle||0) + 90) % 360;
            rerender();
          }catch(e){}
        });
        const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
        rect.setAttribute('x', ctr.x-24); rect.setAttribute('y', ctr.y-34);
        rect.setAttribute('width','48'); rect.setAttribute('height','68'); rect.setAttribute('rx','5');
        const gold = getComputedStyle(document.documentElement).getPropertyValue('--gold').trim() || '#C8A949';
        const silver = getComputedStyle(document.documentElement).getPropertyValue('--silver').trim() || '#C0C0C8';
        rect.setAttribute('fill', pr.owner==='ORANGE'? gold : silver);
        rect.setAttribute('stroke','#333'); rect.setAttribute('opacity','0.95');
        const t = document.createElementNS('http://www.w3.org/2000/svg','text');
        t.setAttribute('x', ctr.x); t.setAttribute('y', ctr.y+8);
        t.setAttribute('text-anchor','middle'); t.setAttribute('font-size','26');
        t.setAttribute('fill', pr.owner==='ORANGE'? '#3e2f20':'#1f2430');
        t.textContent = (card.sym || card.code || '');
        g.appendChild(rect); g.appendChild(t);
        svg.appendChild(g);
      });
    }
// pawns
    for (const p of Object.values(pawns)){
      const n = nodeForPawn(p.id);
      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
      let cx=n.pos.x, cy=n.pos.y;
      if (dragging?.kind==='pawn' && dragging.id===p.id){ cx=dragPoint.x; cy=dragPoint.y; }
      circle.setAttribute('cx', cx); circle.setAttribute('cy', cy); circle.setAttribute('r','16');
      circle.setAttribute('fill', p.owner==='ORANGE'?getComputedStyle(document.documentElement).getPropertyValue('--gold').trim()||'#C8A949':getComputedStyle(document.documentElement).getPropertyValue('--silver').trim()||'#C0C0C8'); circle.setAttribute('stroke','#333'); circle.setAttribute('stroke-width','1.8');
      circle.setAttribute('tabindex','0'); circle.setAttribute('class','focusRing');
      const canDrag = state.turn===p.owner && ((p.mv||0)>0) && (pending.pawnMoves.length<4);
      if (canDrag){ circle.style.cursor='grab'; circle.style.pointerEvents='auto'; circle.addEventListener('pointerdown', ev => startPawnDrag(ev, p.id)); }
      else { circle.style.cursor='default'; circle.style.pointerEvents='none'; }
      svg.appendChild(circle);
    }
  }

  function renderMPDots(el, cur, max){
    el.innerHTML='';
    for (let i=0;i<max;i++){
      const d = document.createElement('div');
      d.className = 'mpDot' + (i < cur ? ' filled' : '');
      el.appendChild(d);
    }
  }
  function renderSidebar(){
    const me = state.turn; const opp = me==='ORANGE'?'BLUE':'ORANGE';
    const handOwnerLabel = document.getElementById('hand-owner');
    handOwnerLabel.textContent = (me==='ORANGE'?'GOLD':'SILVER');
    const handEl = document.getElementById('hand');
    handEl.innerHTML='';
    for (const id of state.players[me].hand){
      const el = document.createElement('div');
      el.className = 'card ' + (id.startsWith('ORANGE')?'gold':'silver');
      el.textContent = cards[id].sym;
      el.title = cards[id].code;
      el.setAttribute('role','button'); el.setAttribute('tabindex','0'); el.classList.add('focusRing');
      el.addEventListener('pointerdown', ev => startRuneDrag(ev, id, me));
      handEl.appendChild(el);
    }
    const deckMe = document.getElementById('deck-me');
    const discardMe = document.getElementById('discard-me');
    const deckOpp = document.getElementById('deck-opp');
    const logEl = document.getElementById('log');
    deckMe.textContent = ''+state.players[me].deck.length;
    discardMe.textContent = ''+state.players[me].discard.length;
    deckOpp.textContent = ''+state.players[opp].deck.length;
    // Blend discard with my color, ensure opp deck stays neutral
    statDiscard.classList.remove('statGold','statSilver');
    statOpp.classList.remove('statGold','statSilver');
    if (me==='ORANGE'){ statDiscard.classList.add('statGold'); }
    else { statDiscard.classList.add('statSilver'); }
    logEl.innerHTML = state.log.map(l=>`<div>${new Date(l.t).toLocaleTimeString()} — ${l.text}</div>`).join('');
    logEl.scrollTop = logEl.scrollHeight;
    // Magic points UI
    try{
      renderMPDots(document.getElementById('mp-me'), state.players[me].mp||0, state.players[me].mpMax||MP_MAX);
      renderMPDots(document.getElementById('mp-opp'), state.players[opp].mp||0, state.players[opp].mpMax||MP_MAX);
    }catch(e){}

    const pendingBadge = document.getElementById('pendingBadge');
    const hasPending = pending.pawnMoves.length>0 || !!pending.rune; pendingBadge.style.display = hasPending ? 'block' : 'none';
  }

  function rerender(){ renderBoard(); renderSidebar(); }

/*__INIT_MV__*/
try{ const cur = state.turn; for (const p of Object.values(pawns)) p.mv = (p.owner===cur)?1:0; }catch(e){}


  // Dragging logic (pawns)
  function startPawnDrag(ev, pawnId){

  // Block if pawn already moved or 4 moves staged
  try{
    const pid = typeof pawnId!=='undefined' ? pawnId : arguments[1];
    const p = pawns && pawns[pid];
    if ((pending.pawnMoves||[]).length >= 4) return;
    if (p && (p.mv||0) <= 0) return;
  }catch(e){}

    if (state.turn !== pawns[pawnId].owner) return;
    dragging = { kind: 'pawn', id: pawnId };
    dragPoint = svgPoint(ev);
    dragPreviewTarget = null;
    svg.setPointerCapture(ev.pointerId);
    svg.addEventListener('pointermove', onPawnMove);
    svg.addEventListener('pointerup', endPawnDrag, { once: true });
    rerender();
  }
  function onPawnMove(ev){
    dragPoint = svgPoint(ev);
    const pawn = pawns[dragging.id]; const fromNode = nodeForPawn(pawn.id);
    let best=null, bestD=Infinity;
    for (const nid of fromNode.neighbors){ const n=nodes[nid]; const dx=n.pos.x-dragPoint.x, dy=n.pos.y-dragPoint.y; const d=dx*dx+dy*dy; if (d<bestD){bestD=d; best=nid;} }
    dragPreviewTarget = (best && bestD<70*70) ? best : null;
    renderBoard();
  }
  function endPawnDrag(ev){
    svg.releasePointerCapture(ev.pointerId);
    svg.removeEventListener('pointermove', onPawnMove);
    if (dragPreviewTarget){
      const pawn = pawns[dragging.id];
      const others = pending.pawnMoves.filter(m=>m.pawnId!==pawn.id);
      const proposed = [...others, { pawnId: pawn.id, to: dragPreviewTarget }];
      if (proposed.length <= 4){
        previewEdges[pawn.id] = dragPreviewTarget;
        pending.pawnMoves = proposed;
        try{ if (pawns[pawn.id]) pawns[pawn.id].mv = 0; }catch(e){}
      }
    }
    dragging = null; dragPreviewTarget = null; rerender();
  }

  // Dragging logic (runes)
  function startRuneDrag(ev, cardId, owner){

  /*__GATE_RUNE_BY_MP__*/
  try{
    const me = state.turn;
    const curMp = (state.players[me].mp||0);
    // Allow starting rune drag if: have at least 2 MP OR already have a pending rune (so you can replace it)
    if (!(curMp >= 2 || pending.rune)){
      return;
    }
  }catch(e){}    

    if (state.turn !== owner) return;
    dragging = { kind:'rune', id: cardId, owner };
    dragPoint = svgPoint(ev);
    dragPreviewTarget = null;
    svg.setPointerCapture(ev.pointerId);
    svg.addEventListener('pointermove', onRuneMove);
    svg.addEventListener('pointerup', endRuneDrag, { once: true });
    rerender();
  }
  function onRuneMove(ev){
    dragPoint = svgPoint(ev);
    let best=null, bestD=Infinity;
    for (const id of cellList){
      const ctr = centers[id]; const dx=ctr.x-dragPoint.x, dy=ctr.y-dragPoint.y; const d=dx*dx+dy*dy;
      if (d<bestD){bestD=d; best=id;}
    }
    dragPreviewTarget = best; renderBoard();
  }
  function endRuneDrag(ev){
    svg.releasePointerCapture(ev.pointerId);
    svg.removeEventListener('pointermove', onRuneMove);
    if (dragPreviewTarget){ pending.rune = { cardId: dragging.id, cellId: dragPreviewTarget }; 
      /*__SPEND_MP_ON_FIRST_RUNE__*/
      try{
        const me = state.turn;
        if (!pending.runeMpSpent && (state.players[me].mp||0) >= 2){ state.players[me].mp = 0; pending.runeMpSpent = true; }
      }catch(e){}
    }
    dragging = null; rerender();
  }

  // Commit turn
  function endTurn(){
    const me = state.turn;
    if (pending.pawnMoves.length>4){ return; }
    const perPawn = new Set(pending.pawnMoves.map(m=>m.pawnId));
    if (perPawn.size !== pending.pawnMoves.length){ return; }
    const dests=new Set();
    for (const m of pending.pawnMoves){
      const pawn = pawns[m.pawnId];
      if (!pawn || pawn.owner!==me) return;
      if (!nodes[pawn.edge].neighbors.includes(m.to)) return;
      if (dests.has(m.to)) return; dests.add(m.to);
    }
    const occupied = new Set(Object.values(pawns).map(p=>p.edge));
    for (const m of pending.pawnMoves){
      if (occupied.has(m.to) && !pending.pawnMoves.some(x=>pawns[x.pawnId].edge===m.to)) return;
    }
    for (const m of pending.pawnMoves){ pawns[m.pawnId].edge = m.to; delete previewEdges[m.pawnId]; }
    // Persist rune placement into game state
    if (pending.rune && pending.rune.cardId && pending.rune.cellId){
      const meOwner = state.turn;
      state.placedRunes.push({ cardId: pending.rune.cardId, cellId: pending.rune.cellId, owner: meOwner });
      try {
        const h = state.players[meOwner].hand;
        state.players[meOwner].hand = h.filter(id => id !== pending.rune.cardId);
      } catch(e) {}
    }

    if (pending.rune){ const hand = state.players[me].hand; state.players[me].hand = hand.filter(id=>id!==pending.rune.cardId); }
    const now = Date.now(); const elapsed = now - lastTurnAt; state.players[me].timeMs = Math.max(0, state.players[me].timeMs - elapsed); lastTurnAt = now;
    state.turn = me==='ORANGE'?'BLUE':'ORANGE';
    // Magic points reset each new turn
    resetAllMagic();
    // Reset per-pawn mv for new player
    try{ const cur = state.turn; for (const p of Object.values(pawns)){ p.mv = (p.owner===cur)?1:0; } }catch(e){}

    const runeText = pending.rune ? ` and placed ${cards[pending.rune.cardId].code} on ${pending.rune.cellId}` : '';
    state.log.push({ t: now, text: `${me} moved ${pending.pawnMoves.length} pawn(s)${runeText}.` });
    pending.pawnMoves = []; safeClearPendingRune(); pending.runeMpSpent = false; dragPreviewTarget=null; rerender(); updateClocks();
  }

  document.getElementById('undoBtn').addEventListener('click', undoLast);
  document.getElementById('endTurn').addEventListener('click', endTurn);
  document.getElementById('resetPending').addEventListener('click', ()=>{ pending.pawnMoves = []; safeClearPendingRune(); pending.runeMpSpent = false; dragPreviewTarget=null; for (const k in previewEdges) delete previewEdges[k]; rerender(); });

  // clocks
  let lastTurnAt = Date.now();
  const cO = document.getElementById('clock-orange'), cB = document.getElementById('clock-blue');
  const fmt = ms => { const s=Math.max(0,Math.floor(ms/1000)); const m=Math.floor(s/60), ss=(s%60).toString().padStart(2,'0'); return `${m}:${ss}`; };
  function updateClocks(){ cO.textContent = fmt(state.players.ORANGE.timeMs); cB.textContent = fmt(state.players.BLUE.timeMs); }
  setInterval(()=>{
    const now = Date.now(); const me = state.turn; const elapsed = now - lastTurnAt;
    const tO = me==='ORANGE' ? state.players.ORANGE.timeMs - elapsed : state.players.ORANGE.timeMs;
    const tB = me==='BLUE'   ? state.players.BLUE.timeMs   - elapsed : state.players.BLUE.timeMs;
    cO.textContent = fmt(tO); cB.textContent = fmt(tB);
  }, 250);

  rerender(); updateClocks();
  function undoLast(){
    if (pending.rune){
      /*__UNDO_RUNE_MP__*/
      try{ if (pending.runeMpSpent){ const me = state.turn; state.players[me].mp = state.players[me].mpMax || MP_MAX; pending.runeMpSpent = false; } }catch(e){}
      pending.rune = null;
      rerender(); return;
    }
    if (pending.pawnMoves && pending.pawnMoves.length>0){
      const last = pending.pawnMoves.pop();
      try{ delete previewEdges[last.pawnId]; }catch(e){}
      try{ if (pawns[last.pawnId]) pawns[last.pawnId].mv = 1; }catch(e){}
      rerender(); return;
    }
  }

})();
</script>

<!-- SAFE HOOK: persistent runes + per-pawn move limit -->
<script>
(function(){
  function ready(){
    return typeof window.state==='object' && typeof window.pending==='object' &&
           typeof window.centers==='object' && typeof window.cards==='object' &&
           typeof window.rerender==='function' &&
           typeof window.startPawnDrag==='function' &&
           typeof window.endPawnDrag==='function' &&
           typeof window.endTurn==='function' &&
           document.getElementById('board');
  }
  function init(){
    if (!ready()){ requestAnimationFrame(init); return; }
    const svg = document.getElementById('board');
    window.boardRunes = window.boardRunes || []; // [{cardId, cellId, owner}]

    // Helper: remove previously drawn persisted runes
    function clearPersisted(){
      for (const el of svg.querySelectorAll('.persisted-rune')) el.remove();
    }
    // Helper: draw one persisted rune using existing style
    function drawPersistedRune(cx, cy, isOrange, sym){
      const r = document.createElementNS('http://www.w3.org/2000/svg','rect');
      r.setAttribute('x', cx-24); r.setAttribute('y', cy-34);
      r.setAttribute('width','48'); r.setAttribute('height','68'); r.setAttribute('rx','5');
      const gold = getComputedStyle(document.documentElement).getPropertyValue('--gold').trim() || '#C8A949';
      const silver = getComputedStyle(document.documentElement).getPropertyValue('--silver').trim() || '#C0C0C8';
      r.setAttribute('fill', isOrange? gold : silver);
      r.setAttribute('stroke','#333'); r.setAttribute('opacity','0.95');
      const t = document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('x', cx); t.setAttribute('y', cy+8);
      t.setAttribute('text-anchor','middle'); t.setAttribute('font-size','26');
      t.setAttribute('fill', isOrange? '#2f2317':'#1f2430'); t.textContent = sym;
      const g = document.createElementNS('http://www.w3.org/2000/svg','g');
      g.appendChild(r); g.appendChild(t);
      g.classList.add('persisted-rune');
      svg.appendChild(g);
      return g;
    }
    // Coords helper
    function svgPoint(evt){
      const pt = svg.createSVGPoint(); pt.x = evt.clientX; pt.y = evt.clientY;
      const m = svg.getScreenCTM().inverse(); const p = pt.matrixTransform(m);
      return { x: p.x, y: p.y };
    }
    function nearestCellId(pt){
      let best=null, bestD=Infinity;
      for (const [id,c] of Object.entries(window.centers)){
        const dx=c.x-pt.x, dy=c.y-pt.y, d=dx*dx+dy*dy;
        if (d<bestD){ bestD=d; best=id; }
      }
      return best;
    }

    // Wrap rerender: after base draws, paint persisted runes and enable owner-drag
    /* SAFE overlay rerender wrapper disabled */
try{ svg.releasePointerCapture(eu.pointerId); }catch(e){}
                svg.removeEventListener('pointerup', onUp);
                try{ window.rerender(); }catch(e){}
              }
              svg.addEventListener('pointerup', onUp, { once:true });
              ev.stopPropagation();
            });
          }
        }
      }catch(e){}
      return res;
    };

    // Persist rune before base endTurn clears pending.rune
    /* SAFE overlay endTurn wrapper disabled */
catch(e){}
          // push to persistent list
          window.boardRunes.push({ cardId: pr.cardId, cellId: pr.cellId, owner: me });
        }
      }catch(e){}
      const res = _endTurn.apply(this, arguments);
      try{ window.rerender(); }catch(e){}
      return res;
    };

    // -------- per-pawn movement cap (mv) --------
    // Initialize mv if missing
    try{
      for (const p of Object.values(window.pawns||{})){
        if (typeof p.mv==='undefined') p.mv = (p.owner===window.state.turn?1:0);
      }
    }catch(e){}
    // Block dragging if mv<=0
    /* disabled SAFE startPawnDrag overlay */
    /* disabled */ function _noopStartPawnDrag (ev, pawnId){
      const p = window.pawns?.[pawnId];
      if (p && p.mv<=0) return;
      return _startPawnDrag.apply(this, arguments);
    };
    // When a move is staged, set mv=0 for that pawn
    /* disabled SAFE endPawnDrag overlay */
    /* disabled */ function _noopEndPawnDrag (){
      const before = new Set((window.pending?.pawnMoves||[]).map(m=>m.pawnId));
      const r = _endPawnDrag.apply(this, arguments);
      try{
        const after = new Set((window.pending?.pawnMoves||[]).map(m=>m.pawnId));
        for (const pid of after){
          if (!before.has(pid) && window.pawns?.[pid]) window.pawns[pid].mv = 0;
        }
      }catch(e){}
      return r;
    };
    // After turn ends, reset mv only for new player's pawns
    const _endTurn2 = window.endTurn;
    window.endTurn = function(){
      const res = _endTurn2.apply(this, arguments);
      try{
        const cur = window.state?.turn;
        if (cur && window.pawns){
          for (const p of Object.values(window.pawns)){
            p.mv = (p.owner===cur)?1:0;
          }
        }
      }catch(e){}
      try{ window.rerender(); }catch(e){}
      return res;
    };

    // First refresh
    try{ window.rerender(); }catch(e){}
  }
  init();
  function undoLast(){
    if (pending.rune){
      /*__UNDO_RUNE_MP__*/
      try{ if (pending.runeMpSpent){ const me = state.turn; state.players[me].mp = state.players[me].mpMax || MP_MAX; pending.runeMpSpent = false; } }catch(e){}
      pending.rune = null;
      rerender(); return;
    }
    if (pending.pawnMoves && pending.pawnMoves.length>0){
      const last = pending.pawnMoves.pop();
      try{ delete previewEdges[last.pawnId]; }catch(e){}
      try{ if (pawns[last.pawnId]) pawns[last.pawnId].mv = 1; }catch(e){}
      rerender(); return;
    }
  }

})();
</script>

</body>
</html>
